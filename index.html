<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Section Extractor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        ul { list-style-type: none; padding-left: 20px; }
        li { margin-bottom: 5px; }
        button { margin-left: 10px; }
    </style>
</head>
<body>
    <h1>PDF Section Extractor</h1>
    <input type="file" id="pdfFile" accept="application/pdf" />
    <br />
    <label>
        <input type="radio" name="format" value="pdf" checked /> PDF
    </label>
    <label>
        <input type="radio" name="format" value="txt" /> Text
    </label>
    <br />
    <label>
        <input type="checkbox" id="iterateAll" /> Iterate all sections
    </label>
    <br />
    <button id="processBtn">Process</button>

    <div id="progress"></div>
    <div id="output"></div>

    <!-- PDF.js and pdf-lib from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script>
        function warnIfLargePDF(file) {
            const progress = document.getElementById('progress');
            progress.textContent = '';
            if (!file) return;
            const memGB = navigator.deviceMemory || 4;
            const limit = memGB * 1024 * 1024 * 1024 * 0.25;
            if (file.size > limit) {
                progress.textContent = 'Warning: large file may exceed available memory. Consider splitting the PDF before upload.';
            }
        }

        document.getElementById('pdfFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            warnIfLargePDF(file);
        });
        async function readOutline(pdf) {
            // Use PDF.js to read the outline/table of contents
            const pdfData = new Uint8Array(await pdf.arrayBuffer());
            const loadingTask = pdfjsLib.getDocument({ data: pdfData });
            const doc = await loadingTask.promise;
            const outline = await doc.getOutline();
            return outline || [];
        }

        function displayOutline(outline, container, prefix = '') {
            const ul = document.createElement('ul');
            outline.forEach((item, idx) => {
                const li = document.createElement('li');
                const title = item.title || '<no title>';
                li.textContent = prefix + title;
                if (item.dest) {
                    const btn = document.createElement('button');
                    btn.textContent = 'Extract';
                    btn.onclick = () => extractSection(item);
                    li.appendChild(btn);
                }
                if (item.items && item.items.length) {
                    displayOutline(item.items, li, prefix + (idx+1) + '.');
                }
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }

        async function extractSection(item) {
            const format = document.querySelector('input[name="format"]:checked').value;
            const fileInput = document.getElementById('pdfFile');
            if (!fileInput.files.length) return;
            const file = fileInput.files[0];
            const arrayBuffer = await file.arrayBuffer();
            const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
            const pageIndex = (item.dest[0].num || 0); // TODO: verify index resolution
            const nextPage = item.next ? (item.next.dest[0].num || pdfDoc.getPageCount()) : pdfDoc.getPageCount();
            const newDoc = await PDFLib.PDFDocument.create();
            for (let i = pageIndex; i < nextPage; i++) {
                const [copied] = await newDoc.copyPages(pdfDoc, [i]);
                newDoc.addPage(copied);
            }
            const bytes = await newDoc.save();
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = (item.title || 'section') + '.pdf';
            a.click();
        }

        document.getElementById('processBtn').addEventListener('click', async () => {
            const fileInput = document.getElementById('pdfFile');
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';
            if (!fileInput.files.length) return;
            const file = fileInput.files[0];
            warnIfLargePDF(file);
            const outline = await readOutline(file);
            if (!outline.length) {
                outputDiv.textContent = 'No outline found.';
                return;
            }
            displayOutline(outline, outputDiv);
        });

        // Display approximate device memory in the footer
        document.addEventListener('DOMContentLoaded', () => {
            const mem = navigator.deviceMemory;
            const memEl = document.getElementById('memory');
            if (memEl) {
                memEl.textContent = mem ? `Approx. ${mem} GB RAM` : 'Memory: unknown';
            }
        });
    </script>
</body>
</html>
